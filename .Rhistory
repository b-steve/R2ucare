}
compteur = 0
effY = Y[,ncol(Y)]
ncol(Y)
Y
library(R2ucare)
group_data_gen(batch,batcheff,1)
if (length(effX) == 1) {
Y <- matrix(c(X,effX))
} else {
Y <- cbind(X,effX)
}
s = rev(s)
for (i in s){
Y <- Y[order(Y[,i]),]
Y <- as.matrix(Y)
}
Y
compteur = 0
effY = Y[,ncol(Y)]
Y = Y[,-ncol(Y)]
i = 1
dim(Y)[1]
library(R2ucare)
group_data_gen(batch,batcheff,1)
batch
batcheff
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
s = rev(s)
for (i in s){
Y <- Y[order(Y[,i]),]
Y <- as.matrix(Y)
}
Y
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
s = rev(s)
Y
order(Y[,i])
Y[order(Y[,i]),]
as.matrix(Y)
t(matrix(c(X,effX)))
library(R2ucare)
group_data_gen(batch,batcheff,1)
test3Gsr(mat,n_history)
mat
n_history
mat <- c()
mat <- read.table("example_matrix", sep="\t",
header = T,
row.names = 1)
# Put the 4 as 0 to assess that all time steps have individuals and that all individuals had a capture
mat[mat==4]<-0
mat <- as.matrix(mat)
dim(mat)
# (1) Assess that there is at least one individual in any time step
check <- as.vector(apply(mat, 2, sum))
sum(check==0)
cat("0 indicates that all sampling occasions had at least 1 individual")
cat("I put it to assess that this was not the error")
# (2) Assess that all individuals were captured at least once
check_indiv <- apply(mat, 1, sum); min(check_indiv)
cat("The minimum value should be 1")
if (min(check_indiv>0)){
cat("Correct")
} else {
cat("error")
}
# Create a vector indicating the number of individuals with this history
# As I create one row per individual I have to put one a 1
n_history <- rep(1, times=nrow(mat))
length(n_history)==nrow(mat)
library(R2ucare)
# Put again the zeros as fours for U_CARE
#mat[mat==0]<-4
test3Gsm(mat,n_history)
mat
mat <- c()
mat <- read.table("example_matrix", sep="\t",
header = T,
row.names = 1)
mat <- read.table("/Users/oliviergimenez/Dropbox/OG/GITHUB/R2ucare/corrected_bugs/ruben/example_matrix", sep="\t",
header = T,
row.names = 1)
mat <- c()
mat <- read.table("/Users/oliviergimenez/Dropbox/OG/GITHUB/R2ucare/corrected_bugs/ruben/example_matrix", sep="\t",
header = T,
row.names = 1)
# Put the 4 as 0 to assess that all time steps have individuals and that all individuals had a capture
mat[mat==4]<-0
mat <- as.matrix(mat)
dim(mat)
# (1) Assess that there is at least one individual in any time step
check <- as.vector(apply(mat, 2, sum))
sum(check==0)
cat("0 indicates that all sampling occasions had at least 1 individual")
cat("I put it to assess that this was not the error")
# (2) Assess that all individuals were captured at least once
check_indiv <- apply(mat, 1, sum); min(check_indiv)
cat("The minimum value should be 1")
if (min(check_indiv>0)){
cat("Correct")
} else {
cat("error")
}
# Create a vector indicating the number of individuals with this history
# As I create one row per individual I have to put one a 1
n_history <- rep(1, times=nrow(mat))
length(n_history)==nrow(mat)
mat
library(R2ucare)
# Put again the zeros as fours for U_CARE
#mat[mat==0]<-4
test3Gsm(mat,n_history)
test3Gsr(mat,n_history)
test3Gwbwa(mat,n_history)
testMitec(mat,n_history)
testMltec(mat,n_history)
overall_JMV(mat,n_history)
##################################################################################################
# Packages
library(NetLogoR)
inqs
install.packages("NetLogoR")
devtools::install_github("PredictiveEcology/NetLogoR")
install.packages("testthat")
install.packages("SpaDES")
install.packages("raster")
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
install.packages("SpaDES")
install.packages("SpaDES")
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
devtools::install_github("PredictiveEcology/NetLogoR")
devtools::install_github("PredictiveEcology/NetLogoR")
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
install.packages("sp")
install.packages("sp")
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
devtools::install_github("PredictiveEcology/NetLogoR")
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
install.packages("sp")
install.packages("sp")
devtools::install_github("PredictiveEcology/NetLogoR")
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
##################################################################################################
# Packages
library(NetLogoR)
library(testthat) # to test parts of the model
library(SpaDES)
library(raster)
# Dispersal submodel
pCorr <- 0.53 # movement correlation probability
# probability to chose the next cell in the same direction as given by the previous step
pMortDisp <- 0.0007 # daily mortality probability for dispersers
# Territory search submodel
minTerrSizeF <- 70 # min number of cells to establish a territory for a female
maxTerrSizeF <- 100 # max number of cells to establish a territory for a female
# Reproduction submodel
pRepro <- 0.81 # probability of reproduction for concerned females
# value from Laetitia thesis (0.75 in St?phanie's models)
nKitty <- c(1, 2) # females can have 1 or 2 kittens if they reproduce
pKitty <- c(0.5, 0.5) # probabilities associated with nKitty
# sex ratio is 1:1 and is not defined as a parameter
minAgeRepro <- 2 # female needs to be at least 2 years old to reproduce
maxAgeRepro <- 9 # female do not reproduce after 9 years old? (not in the original model)
# Annual mortality submodel
pMortRes <- 0.12 # annual mortality probability for residents
# Simple habitat map example
# 1 = breeding cell, 2 = dispersal cell, 3 = matrix cell, 4 = barrier cell
habitatMap <- createWorld(0, 4, 0, 4, data = c(rep(c(2, rep(1, 3), 2), 4), rep(2, 5)))
habitatMap
plot(habitatMap)
# Simple road mortality map
roadMortMap <- createWorld(0, 4, 0, 4, data = 0) # no road
plot(roadMortMap)
plot(habitatMap)
str(habitatMap)
# Territories
# Store territory numbers of the residents
# Territories are unique for each female and cannot overlap
# A male can overlap up to 3 female territories
# Territory numbers are therefore the resident female IDs
terrMap <- createWorld(0, 4, 0, 4, data = c(NA, 0, rep(NA, 23)))
# Map to define the available cells for females to build their territory
# Based on the habitatMap (available cells = breeding cells) and the territory map (available
# cells = non occupied)
# The habitatMap does not change during the simulation but the territory map is updated with
# the settlement of new females so the map of available cells needs to be recomputed each time
# in the territory search submodel
# The part about the cell type (breeding) is done once here
availCells <- createWorld(minPxcor = minPxcor(habitatMap), maxPxcor = maxPxcor(habitatMap),
minPycor = minPycor(habitatMap), maxPycor = maxPycor(habitatMap),
data = 0)
# Give 1 to the cells in availCells that are "breeding" (habitatMap = 1)
availCells <- NLset(world = availCells,
agents = NLwith(world = habitatMap, agents = patches(habitatMap), val = 1),
val = 1)
# Full world made up of all the layers
land <- stackWorlds(habitatMap, roadMortMap, terrMap, availCells)
plot(land)
#####################
# Create a population
# Simple population example. Maybe use data later
# Can create 1 population (lynx object) with a variable "population" for the Vosges and Jura
# Or, can create 2 populations (lynx objects)
# Because the individuals will do the same things, let's have only one population/object
lynx <- createTurtles(n = 5, coords = cbind(xcor = c(1, 1, 2, 1, 3), ycor = c(4, 2, 4, 0, 3)))
plot(land[[1]]) # plot only the habitat layer
points(lynx) # plot the lynx on the habitat
lynx
# Add the variables needed in the population
# Made up for now (no data available yet)
lynx <- turtlesOwn(turtles = lynx, tVar = "pop", tVal = rep("Jura", 5))
lynx
lynx <- turtlesOwn(turtles = lynx, tVar = "sex", tVal = c("F", "M", "F", "M", "M"))
lynx <- turtlesOwn(turtles = lynx, tVar = "age", tVal = c(4, 4, 2, 2, 2))
lynx <- turtlesOwn(turtles = lynx, tVar = "status", tVal = c("res", "res", "disp", "disp", "disp"))
lynx
# Location of the last visited dispersal cell
lynx <- turtlesOwn(turtles = lynx, tVar = "lastDispX", tVal = as.numeric(NA))
lynx <- turtlesOwn(turtles = lynx, tVar = "lastDispY", tVal = as.numeric(NA))
# Number of consecutives steps in matrix cells. Cannot be >= 10, otherwise return to lastDisp
lynx <- turtlesOwn(turtles = lynx, tVar = "nMat", tVal = 0)
# "maleID" for the resident females only: ID (who) of the resident male on the female territory
# None of the males and the dispersers have male associated (i.e., NA value for "maleID")
# Example here: the first female (ID = 0) is associated with the first male (ID = 1)
lynx <- turtlesOwn(turtles = lynx, tVar = "maleID", tVal = c(1, NA, NA, NA, NA))
lynx
# "nFem" for the resident males only: number of females claimed, can be up to 3
# None of the females and dispersers have a number of females claimed (i.e., 0 value for "nFem")
# Example here, the first male (ID = 1) is associated with the first female (ID = 0) so it has
# nFem = 1
lynx <- turtlesOwn(turtles = lynx, tVar = "nFem", tVal = c(0, 1, 0, 0, 0))
lynx
?sample
?expect_equivalent
?neighbors
world2raster
batch <- c(0,0,0,1)
batcheff <- c(1)
X=batch
effX=batcheff
c(X,effX)
t(matrix(c(X,effX)))
group_data_gen(X,effX,1)
library(R2ucare)
group_data_gen(X,effX,1)
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
Y
s = rev(s)
for (i in s){
Y <- Y[order(Y[,i]),]
Y <- as.matrix(Y)
}
s=1
s = rev(s)
for (i in s){
Y <- Y[order(Y[,i]),]
Y <- as.matrix(Y)
}
Y
# sort data
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
order(Y[,i])
i
# sort data
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
Y
library(R2ucare)
group_data_gen(X,effX,1)
# sort data
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
s = rev(s)
for (i in s){
if (nrow(Y) == 1) {
Y <- Y
} else {
Y <- Y[order(Y[,i]),]
}
}
Y
compteur = 0
effY = Y[,ncol(Y)]
Y = Y[,-ncol(Y)]
i = 1
Y
effY
dim(Y)
# sort data
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
s = rev(s)
for (i in s){
if (nrow(Y) == 1) {
Y <- Y
} else {
Y <- Y[order(Y[,i]),]
}
}
# sort data
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
s = rev(s)
for (i in s){
if (nrow(Y) == 1) {
Y <- Y
} else {
Y <- Y[order(Y[,i]),]
}
}
# pool data
Y
nrow(Y)
library(R2ucare)
library(R2ucare)
group_data_gen(X,effX,1)
group_data_gen(X,effX,1)
bla=group_data_gen(X,effX,1)
bla
# sort data
if (length(effX) == 1) {
Y <- t(matrix(c(X,effX)))
} else {
Y <- cbind(X,effX)
}
s = rev(s)
for (i in s){
if (nrow(Y) == 1) {
Y <- Y
} else {
Y <- Y[order(Y[,i]),]
}
}
Y
# pool data
if (nrow(Y)==1){
res <- Y
res
}
if (nrow(Y)>1){
compteur = 0
effY = Y[,ncol(Y)]
Y = Y[,-ncol(Y)]
i = 1
while (i <= dim(Y)[1]){
j = i
while ((j <= dim(Y)[1])&&(sum(Y[i,]==Y[j,])==s)){
j = j+1
}
tot1 = sum((effY[i:(j-1)]>0) * effY[i:(j-1)])
tot2 = sum((effY[i:(j-1)]<0) * effY[i:(j-1)])
if (any(as.logical(tot1))){
compteur = compteur + 1
Y[compteur,] = Y[i,]
effY[compteur] = tot1
}
if (any(as.logical(tot2))){
compteur = compteur + 1
effY[compteur] = tot2
Y[compteur,]=Y[i,]
}
i = j
}
Y = Y[1:compteur,]
effY = effY[1:compteur]
res = cbind(Y,effY)
res
}
res
bla
library(R2ucare)
bla=group_data_gen(X,effX,1)
bla
library(R2ucare)
bla=group_data_gen(X,effX,1)
bla
library(R2ucare)
bla=group_data_gen(X,effX,1)
bla
library(R2ucare)
library(R2ucare)
library(R2ucare)
library(R2ucare)
library(R2ucare)
?rev
library(R2ucare)
library(R2ucare)
library(R2ucare)
data <- read.table("CHfem2016.dat",sep=" ")
data <- read.table("/Users/oliviergimenez/Dropbox/OG/GITHUB/R2ucare/corrected_bugs/sarah/CHfem2016.dat",sep=" ")
head(data)
data <- data[-c(8,18),]
N <- dim(data)[1]
Years <- dim(data)[2]
N
Years
# Perform GOF tests
eff <- rep(1,N)
dataCJS = data
dataCJS[dataCJS>1] = 1
test3sr(dataCJS,eff) #signif
test3sm(dataCJS,eff) #non signif
library(R2ucare)
# Perform GOF tests
eff <- rep(1,N)
dataCJS = data
dataCJS[dataCJS>1] = 1
test3sr(dataCJS,eff) #signif
test3sm(dataCJS,eff) #non signif
test2ct(dataCJS,eff) #non signif
test2cl(dataCJS,eff) #non signif
overall_CJS(dataCJS,eff) # non signif
#Multistate
test3Gsr(data,eff)
library(R2ucare)
data <- read.table("/Users/oliviergimenez/Dropbox/OG/GITHUB/R2ucare/corrected_bugs/sarah/CHfem2016.dat",sep=" ")
head(data)
data <- data[-c(8,18),]
N <- dim(data)[1]
Years <- dim(data)[2]
N
Years
#------------- Test gof
# Perform GOF tests
eff <- rep(1,N)
dataCJS = data
dataCJS[dataCJS>1] = 1
test3sr(dataCJS,eff) #signif
test3sm(dataCJS,eff) #non signif
test2ct(dataCJS,eff) #non signif
test2cl(dataCJS,eff) #non signif
overall_CJS(dataCJS,eff) # non signif
#Multistate
test3Gsr(data,eff)
batch
batcheff
(i+1):k
group_data_gen(batch,batcheff,(i+1):k)
group_data_gen(batch,batcheff,(i+1):k)
group_data_gen(batch,batcheff,(i+1):k)
batch
#Multistate
test3Gsr(data,eff)
batch
batcheff
masque
his[,i]
l
210/16
